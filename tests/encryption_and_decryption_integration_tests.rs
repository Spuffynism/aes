extern crate aes_ndlr;

use aes_ndlr::{AESEncryptionOptions, BlockCipherMode, decrypt_aes_128, encrypt_aes_128, Padding};
use aes_ndlr::key::Key;
use generate::generate_aes_128_cbc_iv;

mod generate;

#[test]
fn encrypt_and_decrypt_ecb() {
    let raw: &[u8] = &[
        0x0, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
        0xcc, 0xdd, 0xee, 0xff,
    ];
    let key = &Key([
        0x00, 0x01, 0x02, 0x03,
        0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f
    ]);
    let cipher = encrypt_aes_128(
        &raw,
        &key,
        &AESEncryptionOptions::new(&BlockCipherMode::ECB, &Padding::None),
    );
    let actual_deciphered = decrypt_aes_128(&cipher, &key, &BlockCipherMode::ECB);

    assert_eq!(raw, &actual_deciphered[..]);
}

#[test]
fn encrypt_and_decrypt_cbc() {
    let raw: &[u8] = &[
        0x0, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
        0xcc, 0xdd, 0xee, 0xff,
        // use multiple blocks to test xor chaining
        0x0, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
        0xcc, 0xdd, 0xee, 0xff,
    ];
    let key = &Key([
        0x00, 0x01, 0x02, 0x03,
        0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f
    ]);

    let iv = &generate_aes_128_cbc_iv();

    let cipher = encrypt_aes_128(
        &raw,
        key,
        &AESEncryptionOptions::new(&BlockCipherMode::CBC(iv), &Padding::None),
    );
    let actual_deciphered = decrypt_aes_128(&cipher, key, &BlockCipherMode::CBC(iv));

    assert_eq!(raw, &actual_deciphered[..]);
}

#[test]
fn encrypt_and_decrypt_ctr() {
    let raw: &[u8] = &[
        0x0, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
        0xcc, 0xdd, 0xee, 0xff,
        // use multiple blocks to test running counter
        0x0, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
        0xcc, 0xdd, 0xee, 0xff,
        0x0, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
        0xcc, 0xdd, 0xee, 0xff,
        0x0, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
        0xcc, 0xdd, 0xee, 0xff,
    ];

    let key = Key::from_string("YELLOW SUBMARINE");
    let mode = BlockCipherMode::CTR(&[0u8; 8]);
    let options = &AESEncryptionOptions::new(&mode, &Padding::None);

    let ciphered = encrypt_aes_128(&raw, &key, &options);
    let deciphered = encrypt_aes_128(&ciphered, &key, &options);

    assert_eq!(deciphered, raw);
}